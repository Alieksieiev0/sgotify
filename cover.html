
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>sgotify: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Alieksieiev0/sgotify/cmd/sgotify/sgotify.go (0.0%)</option>
				
				<option value="file1">github.com/Alieksieiev0/sgotify/pkg/api/album.go (100.0%)</option>
				
				<option value="file2">github.com/Alieksieiev0/sgotify/pkg/api/artist.go (100.0%)</option>
				
				<option value="file3">github.com/Alieksieiev0/sgotify/pkg/api/audiobook.go (100.0%)</option>
				
				<option value="file4">github.com/Alieksieiev0/sgotify/pkg/api/category.go (100.0%)</option>
				
				<option value="file5">github.com/Alieksieiev0/sgotify/pkg/api/chapter.go (100.0%)</option>
				
				<option value="file6">github.com/Alieksieiev0/sgotify/pkg/api/client.go (68.3%)</option>
				
				<option value="file7">github.com/Alieksieiev0/sgotify/pkg/api/episode.go (100.0%)</option>
				
				<option value="file8">github.com/Alieksieiev0/sgotify/pkg/api/param.go (12.3%)</option>
				
				<option value="file9">github.com/Alieksieiev0/sgotify/pkg/api/player.go (93.9%)</option>
				
				<option value="file10">github.com/Alieksieiev0/sgotify/pkg/api/playlist.go (90.6%)</option>
				
				<option value="file11">github.com/Alieksieiev0/sgotify/pkg/api/search.go (100.0%)</option>
				
				<option value="file12">github.com/Alieksieiev0/sgotify/pkg/api/show.go (100.0%)</option>
				
				<option value="file13">github.com/Alieksieiev0/sgotify/pkg/api/track.go (100.0%)</option>
				
				<option value="file14">github.com/Alieksieiev0/sgotify/pkg/api/user.go (96.2%)</option>
				
				<option value="file15">github.com/Alieksieiev0/sgotify/pkg/api/utility.go (73.7%)</option>
				
				<option value="file16">github.com/Alieksieiev0/sgotify/pkg/auth/auth.go (0.0%)</option>
				
				<option value="file17">github.com/Alieksieiev0/sgotify/pkg/services/callback_server.go (0.0%)</option>
				
				<option value="file18">github.com/Alieksieiev0/sgotify/pkg/services/services.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "log"

        "github.com/Alieksieiev0/sgotify/pkg/api"
        "github.com/Alieksieiev0/sgotify/pkg/services"
        "github.com/joho/godotenv"
)

func main() <span class="cov0" title="0">{
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("couldn`t load env", err)
        }</span>
        <span class="cov0" title="0">ctx := context.Background()
        term := services.NewTerminal("http://localhost:8888/callback")
        token, err := term.Authorize(ctx)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return
        }</span>

        <span class="cov0" title="0">spotify := api.NewSpotifyClient(ctx, token)
        artist, err := spotify.GetArtist("57dN52uHvrHOxijzpIgu3E")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return
        }</span>
        <span class="cov0" title="0">fmt.Println(artist)
        artists, err := spotify.GetArtists([]string{"0TnOYISbd1XYRBk9myaseg", "57dN52uHvrHOxijzpIgu3E"})
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                return
        }</span>
        <span class="cov0" title="0">fmt.Println(artists)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "fmt"
        "strings"
)

type SimplifiedAlbum struct {
        AlbumType            string             `json:"album_type"`
        TotalTracks          int                `json:"total_tracks"`
        AvailableMarkets     []string           `json:"available_markets"`
        ExternalURLs         ExternalURL        `json:"external_urls"`
        Href                 string             `json:"href"`
        Id                   string             `json:"id"`
        Images               []Image            `json:"images"`
        Name                 string             `json:"name"`
        ReleaseDate          string             `json:"release_date"`
        ReleaseDatePrecision string             `json:"release_date_precision"`
        Restrictions         Restriction        `json:"restrictions"`
        Type                 string             `json:"type"`
        Uri                  string             `json:"uri"`
        Artists              []SimplifiedArtist `json:"artists"`
}

type Copyright struct {
        Text string `json:"text"`
        Type string `json:"type"`
}

type FullAlbum struct {
        SimplifiedAlbum
        Tracks      SimplifiedTrackChunk `json:"tracks"`
        Copyrights  []Copyright          `json:"copyrights"`
        ExternalIds ExternalId           `json:"external_ids"`
        Genres      []string             `json:"genres"`
        Label       string               `json:"label"`
        Popularity  int                  `json:"popularity"`
}

func (s *Spotify) GetAlbum(id string, params ...Param) (*FullAlbum, error) <span class="cov8" title="1">{
        album := &amp;FullAlbum{}
        err := s.Get(album, fmt.Sprintf("/albums/%s", id), params...)
        return album, err
}</span>

func (s *Spotify) GetAlbums(ids []string, params ...Param) ([]*FullAlbum, error) <span class="cov8" title="1">{
        var w struct {
                Albums []*FullAlbum `json:"albums"`
        }
        err := s.Get(&amp;w, fmt.Sprintf("/albums?ids=%s", strings.Join(ids, ",")), params...)
        return w.Albums, err
}</span>

func (s *Spotify) GetAlbumTracks(id string, params ...Param) (*SimplifiedTrackChunk, error) <span class="cov8" title="1">{
        trackChunck := &amp;SimplifiedTrackChunk{}
        err := s.Get(trackChunck, fmt.Sprintf("/albums/%s/tracks", id), params...)
        return trackChunck, err
}</span>

func (s *Spotify) GetUserSavedAlbums(params ...Param) (*SimplifiedAlbumChunk, error) <span class="cov8" title="1">{
        albumChunk := &amp;SimplifiedAlbumChunk{}
        err := s.Get(albumChunk, "/me/albums", params...)
        return albumChunk, err
}</span>

func (s *Spotify) SaveAlbumsForCurrentUser(ids []string) error <span class="cov8" title="1">{
        return s.Put(nil, fmt.Sprintf("/me/albums?ids=%s", strings.Join(ids, ",")), []byte{})
}</span>

func (s *Spotify) RemoveUserSavedAlbums(ids []string) error <span class="cov8" title="1">{
        return s.Delete(nil, fmt.Sprintf("/me/albums?ids=%s", strings.Join(ids, ",")), []byte{})
}</span>

func (s *Spotify) CheckUserSavedAlbums(ids []string) ([]bool, error) <span class="cov8" title="1">{
        containmentInfo := []bool{}
        err := s.Get(
                &amp;containmentInfo,
                fmt.Sprintf("/me/albums/contains?ids=%s", strings.Join(ids, ",")),
        )
        return containmentInfo, err
}</span>

func (s *Spotify) GetNewReleases(params ...Param) (*SimplifiedAlbumChunk, error) <span class="cov8" title="1">{
        var w struct {
                Albums *SimplifiedAlbumChunk `json:"albums"`
        }
        err := s.Get(&amp;w, "/browse/new-releases")
        return w.Albums, err
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "fmt"
        "strings"
)

type SimplifiedArtist struct {
        ExternalURLs ExternalURL `json:"external_urls"`
        Href         string      `json:"href"`
        Id           string      `json:"id"`
        Name         string      `json:"name"`
        Type         string      `json:"type"`
        Uri          string      `json:"uri"`
}

type FullArtist struct {
        SimplifiedArtist
        Followers  Follower `json:"followers"`
        Genres     []string `json:"genres"`
        Images     []Image  `json:"images"`
        Popularity float64  `json:"popularity"`
}

func (s *Spotify) GetArtist(id string) (*FullArtist, error) <span class="cov8" title="1">{
        artist := &amp;FullArtist{}
        err := s.Get(artist, fmt.Sprintf("/artists/%s", id))
        return artist, err
}</span>

func (s *Spotify) GetArtists(ids []string) ([]*FullArtist, error) <span class="cov8" title="1">{
        var w struct {
                Artists []*FullArtist `json:"artists"`
        }
        err := s.Get(&amp;w, fmt.Sprintf("/artists?ids=%s", strings.Join(ids, ",")))
        return w.Artists, err
}</span>

func (s *Spotify) GetArtistAlbums(id string, params ...Param) (*SimplifiedAlbumChunk, error) <span class="cov8" title="1">{
        albumChunk := &amp;SimplifiedAlbumChunk{}
        err := s.Get(albumChunk, fmt.Sprintf("/artists/%s/albums", id), params...)
        return albumChunk, err
}</span>

func (s *Spotify) GetArtistTopTracks(id string, params ...Param) ([]*FullTrack, error) <span class="cov8" title="1">{
        var w struct {
                Tracks []*FullTrack `json:"tracks"`
        }
        err := s.Get(&amp;w, fmt.Sprintf("/artists/%s/top-tracks", id), params...)
        return w.Tracks, err
}</span>

func (s *Spotify) GetArtistRelatedArtists(id string) ([]*FullArtist, error) <span class="cov8" title="1">{
        var w struct {
                Artists []*FullArtist `json:"artists"`
        }
        err := s.Get(&amp;w, fmt.Sprintf("/artists/%s/related-artists", id))
        return w.Artists, err
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "fmt"
        "strings"
)

type Author struct {
        Name string `json:"name"`
}

type Narrator struct {
        Name string `json:"name"`
}

type SimplifiedAudiobook struct {
        Authors          []Author    `json:"authors"`
        AvailableMarkets []string    `json:"available_markets"`
        Copyrights       []Copyright `json:"copyrights"`
        Description      string      `json:"description"`
        HtmlDescription  string      `json:"html_description"`
        Edition          string      `json:"edition"`
        Explicit         bool        `json:"explicit"`
        ExternalURLs     ExternalURL `json:"external_urls"`
        Href             string
        Id               string
        Images           []Image
        Languages        []string
        MediaType        string
        Name             string
        Narrators        []Narrator
        Publisher        string
        Type             string
        URI              string
        TotalChapters    int
}

type FullAudiobook struct {
        SimplifiedAudiobook
        Chapters SimplifiedChapterChunk `json:"chapters"`
}

func (s *Spotify) GetAudiobook(id string, params ...Param) (*FullAudiobook, error) <span class="cov8" title="1">{
        audiobook := &amp;FullAudiobook{}
        err := s.Get(audiobook, fmt.Sprintf("/audiobooks/%s", id), params...)
        return audiobook, err
}</span>

func (s *Spotify) GetAudiobooks(ids []string, params ...Param) ([]*FullAudiobook, error) <span class="cov8" title="1">{
        var w struct {
                Audiobooks []*FullAudiobook `json:"audiobooks"`
        }
        err := s.Get(&amp;w, fmt.Sprintf("/audiobooks?ids=%s", strings.Join(ids, ",")), params...)
        return w.Audiobooks, err
}</span>

func (s *Spotify) GetAudiobookChapters(
        id string,
        params ...Param,
) (*SimplifiedChapterChunk, error) <span class="cov8" title="1">{
        chapterChunk := &amp;SimplifiedChapterChunk{}
        err := s.Get(chapterChunk, fmt.Sprintf("/audiobooks/%s/chapters", id), params...)
        return chapterChunk, err
}</span>

func (s *Spotify) GetUserSavedAudiobooks(params ...Param) (*SimplifiedAudiobookChunk, error) <span class="cov8" title="1">{
        audiobookChunk := &amp;SimplifiedAudiobookChunk{}
        err := s.Get(audiobookChunk, "/me/audiobooks", params...)
        return audiobookChunk, err
}</span>

func (s *Spotify) SaveAudiobooksForCurrentUser(ids []string) error <span class="cov8" title="1">{
        return s.Put(nil, fmt.Sprintf("/me/audiobooks?ids=%s", strings.Join(ids, ",")), []byte{})
}</span>

func (s *Spotify) RemoveUserSavedAudiobooks(ids []string) error <span class="cov8" title="1">{
        return s.Delete(nil, fmt.Sprintf("/me/audiobooks?ids=%s", strings.Join(ids, ",")), []byte{})
}</span>

func (s *Spotify) CheckUserSavedAudiobooks(ids []string) ([]bool, error) <span class="cov8" title="1">{
        containmentInfo := []bool{}
        err := s.Get(
                &amp;containmentInfo,
                fmt.Sprintf("/me/audiobooks/contains?ids=%s", strings.Join(ids, ",")),
        )
        return containmentInfo, err
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import "fmt"

type Category struct {
        Href  string  `json:"href"`
        Icons []Image `json:"icons"`
        Id    string  `json:"id"`
        Name  string  `json:"name"`
}

func (s *Spotify) GetBrowseCategory(id string, params ...Param) (*Category, error) <span class="cov8" title="1">{
        category := &amp;Category{}
        err := s.Get(category, fmt.Sprintf("/browse/categories/%s", id), params...)
        return category, err
}</span>

func (s *Spotify) GetBrowseCategories(params ...Param) (*CategoryChunk, error) <span class="cov8" title="1">{
        var w struct {
                Categories *CategoryChunk `json:"categories"`
        }
        err := s.Get(&amp;w, "/browse/categories", params...)
        return w.Categories, err
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package api

import (
        "fmt"
        "strings"
)

type SimplifiedChapter struct {
        AudioPreviewUrl      string           `json:"audio_preview_url"`
        AvailableMarkets     []string         `json:"available_markets"`
        ChapterNubmer        int              `json:"chapter_nubmer"`
        Description          string           `json:"description"`
        HtmlDescription      string           `json:"html_description"`
        DurationMs           int              `json:"duration_ms"`
        Explicit             bool             `json:"explicit"`
        ExternalURLs         ExternalURL      `json:"external_urls"`
        Href                 string           `json:"href"`
        Id                   string           `json:"id"`
        Images               []Image          `json:"images"`
        IsPlayable           bool             `json:"is_playable"`
        Languages            []string         `json:"languages"`
        Name                 string           `json:"name"`
        ReleaseDate          string           `json:"release_date"`
        ReleaseDatePrecision string           `json:"release_date_precision"`
        ResumePoint          AudioResumePoint `json:"resume_point"`
        Type                 string           `json:"type"`
        URI                  string           `json:"uri"`
        Restrictions         Restriction      `json:"restrictions"`
}

type FullChapter struct {
        SimplifiedChapter
        Audiobook SimplifiedAudiobook `json:"audiobook"`
}

func (s *Spotify) GetChapter(id string, params ...Param) (*FullChapter, error) <span class="cov8" title="1">{
        chapter := &amp;FullChapter{}
        err := s.Get(chapter, fmt.Sprintf("/chapters/%s", id), params...)
        return chapter, err
}</span>

func (s *Spotify) GetChapters(ids []string, params ...Param) ([]*FullChapter, error) <span class="cov8" title="1">{
        var w struct {
                Chapters []*FullChapter `json:"chapters"`
        }
        err := s.Get(&amp;w, fmt.Sprintf("/chapters?ids=%s", strings.Join(ids, ",")), params...)
        return w.Chapters, err
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"

        "golang.org/x/oauth2"
)

type Error struct {
        Status  int    `json:"status"`
        Message string `json:"message"`
}

type Spotify struct {
        client *http.Client
        url    string
}

type spotifyRequestData struct {
        response interface{}
        method   string
        endpoint string
        params   []Param
        headers  map[string]string
        body     io.Reader
}

func (s *Spotify) Get(response interface{}, endpoint string, params ...Param) error <span class="cov8" title="1">{
        requestData := spotifyRequestData{
                response,
                http.MethodGet,
                endpoint,
                params,
                map[string]string{},
                bytes.NewBuffer([]byte{}),
        }

        return s.doRequest(requestData)
}</span>

func (s *Spotify) Put(
        response interface{},
        endpoint string,
        body []byte,
        params ...Param,
) error <span class="cov8" title="1">{
        requestData := spotifyRequestData{
                response,
                http.MethodPut,
                endpoint,
                params,
                map[string]string{"Content-Type": "application/json"},
                bytes.NewBuffer(body),
        }

        return s.doRequest(requestData)
}</span>

func (s *Spotify) PutImage(
        response interface{},
        endpoint, body string,
        params ...Param,
) error <span class="cov8" title="1">{
        requestData := spotifyRequestData{
                response,
                http.MethodPut,
                endpoint,
                params,
                map[string]string{"Content-Type": "image/jpeg"},
                strings.NewReader(body),
        }

        return s.doRequest(requestData)
}</span>

func (s *Spotify) Post(
        response interface{},
        endpoint string,
        body []byte,
        params ...Param,
) error <span class="cov8" title="1">{
        requestData := spotifyRequestData{
                response,
                http.MethodPost,
                endpoint,
                params,
                map[string]string{"Content-Type": "application/json"},
                bytes.NewBuffer(body),
        }

        return s.doRequest(requestData)
}</span>

func (s *Spotify) Delete(
        response interface{},
        endpoint string,
        body []byte,
        params ...Param,
) error <span class="cov8" title="1">{
        requestData := spotifyRequestData{
                response,
                http.MethodDelete,
                endpoint,
                params,
                map[string]string{},
                bytes.NewBuffer(body),
        }

        return s.doRequest(requestData)
}</span>

func (s *Spotify) doRequest(data spotifyRequestData) error <span class="cov8" title="1">{
        req, err := s.createRequest(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return s.sendRequest(data.response, req)</span>
}

func (s *Spotify) createRequest(data spotifyRequestData) (*http.Request, error) <span class="cov8" title="1">{
        endpoint, err := buildUrl(data.endpoint, data.params...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest(data.method, s.url+endpoint, data.body)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(1)
                return nil, err
        }</span>
        <span class="cov8" title="1">for k, v := range data.headers </span><span class="cov8" title="1">{
                req.Header.Set(k, v)
        }</span>
        <span class="cov8" title="1">return req, err</span>
}

func (s *Spotify) sendRequest(resData interface{}, req *http.Request) error <span class="cov8" title="1">{
        res, err := s.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">body, err := io.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if res.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return s.handleError(body)
        }</span>
        <span class="cov8" title="1">if resData == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return json.Unmarshal(body, resData)</span>
}

func (s *Spotify) handleError(body []byte) error <span class="cov0" title="0">{
        var w struct {
                Error Error `json:"error"`
        }
        err := json.Unmarshal(body, &amp;w)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("spotify request error: %v", w.Error)</span>
}

func NewSpotifyClient(ctx context.Context, token *oauth2.Token) Spotify <span class="cov0" title="0">{
        return Spotify{
                oauth2.NewClient(ctx, oauth2.StaticTokenSource(token)),
                "https://api.spotify.com/v1",
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import (
        "fmt"
        "strings"
)

type SimplifiedEpisode struct {
        AudioRecording
        AudioPreviewUrl      string           `json:"audio_preview_url"`
        Description          string           `json:"description"`
        HtmlDescription      string           `json:"html_description"`
        Images               []Image          `json:"images"`
        IsExternallyHosted   bool             `json:"is_externally_hosted"`
        Languages            []string         `json:"languages"`
        ReleaseDate          string           `json:"release_date"`
        ReleaseDatePrecision string           `json:"release_date_precision"`
        ResumePoint          AudioResumePoint `json:"resume_point"`
        Type                 string           `json:"type"`
        URI                  string           `json:"uri"`
}

type FullEpisode struct {
        SimplifiedEpisode
        Show SimplifiedShow `json:"show"`
}

type SavedEpisode struct {
        FullEpisode
        AddedAt string `json:"added_at"`
}

func (s *Spotify) GetEpisode(id string, params ...Param) (*FullEpisode, error) <span class="cov8" title="1">{
        episode := &amp;FullEpisode{}
        err := s.Get(episode, fmt.Sprintf("/episodes/%s", id), params...)
        return episode, err
}</span>

func (s *Spotify) GetEpisodes(ids []string, params ...Param) ([]*FullEpisode, error) <span class="cov8" title="1">{
        var w struct {
                Episodes []*FullEpisode `json:"episodes"`
        }
        err := s.Get(&amp;w, fmt.Sprintf("/episodes?ids=%s", strings.Join(ids, ",")), params...)
        return w.Episodes, err
}</span>

func (s *Spotify) GetUserSavedEpisodes(params ...Param) (*SavedEpisodeChunk, error) <span class="cov8" title="1">{
        episodeChunk := &amp;SavedEpisodeChunk{}
        err := s.Get(episodeChunk, "/me/episodes", params...)
        return episodeChunk, err
}</span>

func (s *Spotify) SaveEpisodesForCurrentUser(ids []string) error <span class="cov8" title="1">{
        return s.Put(nil, fmt.Sprintf("/me/episodes?ids=%s", strings.Join(ids, ",")), []byte{})
}</span>

func (s *Spotify) RemoveUserSavedEpisodes(ids []string) error <span class="cov8" title="1">{
        return s.Delete(nil, fmt.Sprintf("/me/episodes?ids=%s", strings.Join(ids, ",")), []byte{})
}</span>

func (s *Spotify) CheckUserSavedEpisodes(ids []string) ([]bool, error) <span class="cov8" title="1">{
        containmentInfo := []bool{}
        err := s.Get(
                &amp;containmentInfo,
                fmt.Sprintf("/me/episodes/contains?ids=%s", strings.Join(ids, ",")),
        )
        return containmentInfo, err
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package api

import (
        "net/url"
        "strconv"
)

type Param func(v *url.Values)

func IncludeGroups(keywords string) Param <span class="cov8" title="1">{
        return func(v *url.Values) </span><span class="cov8" title="1">{
                v.Add("include_groups", keywords)
        }</span>
}

func Market(name string) Param <span class="cov8" title="1">{
        return func(v *url.Values) </span><span class="cov8" title="1">{
                v.Add("market", name)
        }</span>
}

func Fields(names string) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("fields", names)
        }</span>
}

func AdditionalTypes(types string) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("additional_types", types)
        }</span>
}

func Locale(name string) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("locale", name)
        }</span>
}

func Limit(num int) Param <span class="cov8" title="1">{
        return func(v *url.Values) </span><span class="cov8" title="1">{
                v.Add("limit", strconv.Itoa(num))
        }</span>
}

// replace to work with dates
func After(num int) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("after", strconv.Itoa(num))
        }</span>
}

func Before(num int) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("before", strconv.Itoa(num))
        }</span>
}

func Offset(num int) Param <span class="cov8" title="1">{
        return func(v *url.Values) </span><span class="cov8" title="1">{
                v.Add("offset", strconv.Itoa(num))
        }</span>
}

func DeviceId(id string) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("device_id", id)
        }</span>
}

func URIs(ids string) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("uris", ids)
        }</span>
}

func Position(num int) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("position", strconv.Itoa(num))
        }</span>
}

func SeedArtists(ids string) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("seed_artists", ids)
        }</span>
}

func SeedGenres(names string) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("seed_genres", names)
        }</span>
}

func SeedTracks(ids string) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("seed_tracks", ids)
        }</span>
}

func MinAcousticness(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("min_acousticness", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func MaxAcousticness(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("max_acousticness", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func TargetAcousticness(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("target_acousticness", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func MinDanceability(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("min_danceability", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func MaxDanceability(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("max_danceability", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func TargetDanceability(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("target_danceability", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func MinDurationMs(num int) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("min_duration_ms", strconv.Itoa(num))
        }</span>
}

func MaxDurationMs(num int) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("max_duration_ms", strconv.Itoa(num))
        }</span>
}

func TargetDurationMs(num int) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("target_duration_ms", strconv.Itoa(num))
        }</span>
}

func MinEnergy(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("min_energy", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func MaxEnergy(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("max_energy", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func TargetEnergy(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("target_energy", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func MinInstrumentalness(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("min_instrumentalness", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func MaxInstrumentalness(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("max_instrumentalness", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func TargetInstrumentalness(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("target_instrumentalness", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func MinKey(num int) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("min_key", strconv.Itoa(num))
        }</span>
}

func MaxKey(num int) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("max_key", strconv.Itoa(num))
        }</span>
}

func TargetKey(num int) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("target_key", strconv.Itoa(num))
        }</span>
}

func MinLiveness(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("min_liveness", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func MaxLiveness(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("max_liveness", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func TargetLiveness(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("target_liveness", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func MinLoudness(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("min_loudness", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func MaxLoudness(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("max_loudness", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func TargetLoudness(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("target_loudness", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func MinMode(num int) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("min_mode", strconv.Itoa(num))
        }</span>
}

func MaxMode(num int) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("max_mode", strconv.Itoa(num))
        }</span>
}

func TargetMode(num int) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("target_mode", strconv.Itoa(num))
        }</span>
}

func MinPopularity(num int) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("min_popularity", strconv.Itoa(num))
        }</span>
}

func MaxPopularity(num int) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("max_popularity", strconv.Itoa(num))
        }</span>
}

func TargetPopularity(num int) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("target_popularity", strconv.Itoa(num))
        }</span>
}

func MinSpeechiness(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("min_spechiness", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func MaxSpeechiness(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("max_spechiness", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func TargetSpeechiness(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("target_spechiness", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func MinTempo(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("min_tempo", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func MaxTempo(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("max_tempo", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func TargetTempo(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("target_tempo", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func MinTimeSignature(num int) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("min_time_signature", strconv.Itoa(num))
        }</span>
}

func MaxTimeSignature(num int) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("max_time_signature", strconv.Itoa(num))
        }</span>
}

func TargetTimeSignature(num int) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("target_time_signature", strconv.Itoa(num))
        }</span>
}

func MinValence(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("min_valence", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func MaxValence(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("max_valence", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func TargetValence(num float64) Param <span class="cov0" title="0">{
        return func(v *url.Values) </span><span class="cov0" title="0">{
                v.Add("target_valence", strconv.FormatFloat(num, 'f', 2, 64))
        }</span>
}

func buildUrl(path string, params ...Param) (string, error) <span class="cov8" title="1">{
        parsedUrl, err := url.Parse(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">parsedUrl.RawQuery = appendToQuery(parsedUrl.Query(), params...).Encode()
        return parsedUrl.String(), nil</span>
}

func appendToQuery(query url.Values, params ...Param) url.Values <span class="cov8" title="1">{
        for _, param := range params </span><span class="cov8" title="1">{
                param(&amp;query)
        }</span>

        <span class="cov8" title="1">return query</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package api

import (
        "encoding/json"
        "fmt"
)

type Device struct {
        Id               string `json:"id"`
        IsActive         bool   `json:"is_active"`
        IsPrivateSession bool   `json:"is_private_session"`
        IsRestricted     bool   `json:"is_restricted"`
        Name             string `json:"name"`
        Type             string `json:"type"`
        VolumePercent    int    `json:"volume_percent"`
        SupportsVolume   bool   `json:"supports_volume"`
}

type Context struct {
        Type         string      `json:"type"`
        Href         string      `json:"href"`
        ExternalURLs ExternalURL `json:"external_urls"`
        URI          string      `json:"uri"`
}

type Actions struct {
        InterruptingPlayback  bool `json:"interrupting_playback"`
        Pausing               bool `json:"pausing"`
        Resuming              bool `json:"resuming"`
        Seeking               bool `json:"seeking"`
        SkippingNext          bool `json:"skipping_next"`
        SkippingPrev          bool `json:"skipping_prev"`
        TogglingRepeatContext bool `json:"toggling_repeat_context"`
        TogglingShuffle       bool `json:"toggling_shuffle"`
        TogglingRepeatTrack   bool `json:"toggling_repeat_track"`
        TransferingPlayback   bool `json:"transfering_playback"`
}

type Playback struct {
        Device               Device  `json:"device"`
        RepeatState          string  `json:"repeat_state"`
        ShuffleState         bool    `json:"shuffle_state"`
        Context              Context `json:"context"`
        Timestamp            int     `json:"timestamp"`
        ProgressMs           int     `json:"progress_ms"`
        IsPlaying            bool    `json:"is_playing"`
        Item                 Item    `json:"item"`
        CurrentlyPlayingType string  `json:"currently_playing_type"`
        Actions              Actions `json:"actions"`
}

type Cursors struct {
        After  string `json:"after"`
        Before string `json:"before"`
}

type PlayHistory struct {
        Track    FullTrack `json:"track"`
        PlayedAt string    `json:"played_at"`
        Context  Context   `json:"context"`
}

type RecentlyPlayedTracks struct {
        Href    string        `json:"href"`
        Limit   int           `json:"limit"`
        Next    string        `json:"next"`
        Cursors Cursors       `json:"cursors"`
        Total   int           `json:"total"`
        Items   []PlayHistory `json:"items"`
}

type UserQueue struct {
        CurrentlyPlaying Item   `json:"currently_playing"`
        Queue            []Item `json:"queue"`
}

func (s *Spotify) GetPlaybackState(params ...Param) (*Playback, error) <span class="cov8" title="1">{
        playback := &amp;Playback{}
        err := s.Get(playback, "/me/player", params...)
        return playback, err
}</span>

func (s *Spotify) TransferPlayback(deviceIds []string, play bool) error <span class="cov8" title="1">{
        w := struct {
                DeviceIds []string `json:"device_ids"`
                Play      bool     `json:"play"`
        }{
                deviceIds,
                play,
        }
        body, err := json.Marshal(w)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return s.Put(nil, "/me/player", body)</span>
}

func (s *Spotify) GetAvailableDevices() ([]*Device, error) <span class="cov8" title="1">{
        var w struct {
                Devices []*Device `json:"devices"`
        }
        err := s.Get(&amp;w, "/me/player/devices")
        return w.Devices, err
}</span>

func (s *Spotify) GetCurrentlyPlayingTrack(params ...Param) (*Playback, error) <span class="cov8" title="1">{
        playback := &amp;Playback{}
        err := s.Get(playback, "/me/player/currently-playing", params...)
        return playback, err
}</span>

func (s *Spotify) StartResumePlayback(
        contextUri string,
        URIs []string,
        offset interface{},
        positionMs int,
        params ...Param,
) error <span class="cov8" title="1">{
        w := struct {
                ContextURI string      `json:"context_uri"`
                URIs       []string    `json:"uris"`
                Offset     interface{} `json:"offset"`
                PositionMs int         `json:"position_ms"`
        }{
                contextUri,
                URIs,
                offset,
                positionMs,
        }
        body, err := json.Marshal(w)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return s.Put(nil, "/me/player/play", body, params...)</span>
}

func (s *Spotify) PausePlayback(params ...Param) error <span class="cov8" title="1">{
        return s.Put(nil, "/me/player/pause", []byte{}, params...)
}</span>

func (s *Spotify) SkipToNext(params ...Param) error <span class="cov8" title="1">{
        return s.Put(nil, "/me/player/next", []byte{}, params...)
}</span>

func (s *Spotify) SkipToPrevious(params ...Param) error <span class="cov8" title="1">{
        return s.Put(nil, "/me/player/previous", []byte{}, params...)
}</span>

func (s *Spotify) SeekToPosition(positionMs int, params ...Param) error <span class="cov8" title="1">{
        return s.Put(
                nil,
                fmt.Sprintf("/me/player/seek?position_ms=%d", positionMs),
                []byte{},
                params...)
}</span>

func (s *Spotify) SetRepeatMode(state string, params ...Param) error <span class="cov8" title="1">{
        return s.Put(nil, fmt.Sprintf("/me/player/repeat?state=%s", state), []byte{}, params...)
}</span>

func (s *Spotify) SetPlaybackVolume(volumePercent int, params ...Param) error <span class="cov8" title="1">{
        return s.Put(
                nil,
                fmt.Sprintf("/me/player/volume?volume_percent=%d", volumePercent),
                []byte{},
                params...)
}</span>

func (s *Spotify) TogglePlaybackShuffle(state bool, params ...Param) error <span class="cov8" title="1">{
        return s.Put(
                nil,
                fmt.Sprintf("/me/player/shuffle?boolean=%t", state),
                []byte{},
                params...)
}</span>

func (s *Spotify) GetRecentlyPlayedTracks(params ...Param) (*RecentlyPlayedTracks, error) <span class="cov8" title="1">{
        tracks := &amp;RecentlyPlayedTracks{}
        err := s.Get(tracks, "/me/player/recently-played", params...)
        return tracks, err
}</span>

func (s *Spotify) GetUserQueue() (*UserQueue, error) <span class="cov8" title="1">{
        queue := &amp;UserQueue{}
        err := s.Get(queue, "/me/player/queue")
        return queue, err
}</span>

func (s *Spotify) AddItemToPlaybackQueue(URI string, params ...Param) error <span class="cov8" title="1">{
        return s.Put(nil, fmt.Sprintf("/me/player/queue?uri=%s", URI), []byte{}, params...)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package api

import (
        "encoding/json"
        "fmt"
)

type PlaylistOwner struct {
        ExternalURLs ExternalURL `json:"external_urls"`
        Followers    Follower    `json:"followers"`
        Href         string      `json:"href"`
        Id           string      `json:"id"`
        Type         string      `json:"type"`
        URI          string      `json:"uri"`
        DisplayName  string      `json:"display_name"`
}

type PlaylistTrack struct {
        AddedAt string        `json:"added_at"`
        AddedBy PlaylistOwner `json:"added_by"`
        IsLocal bool          `json:"is_local"`
        Track   Item          `json:"track"`
}

type SimplifiedPlaylist struct {
        Collaborative bool               `json:"collaborative"`
        Description   string             `json:"description"`
        ExternalURLs  ExternalURL        `json:"external_urls"`
        Href          string             `json:"href"`
        Id            string             `json:"id"`
        Images        []Image            `json:"images"`
        Name          string             `json:"name"`
        Owner         PlaylistOwner      `json:"owner"`
        Public        bool               `json:"public"`
        SnapshotId    string             `json:"snapshot_id"`
        Tracks        PlaylistTrackChunk `json:"tracks"`
        Type          string             `json:"type"`
        URI           string             `json:"uri"`
}

type FullPlaylist struct {
        SimplifiedPlaylist
        Followers Follower `json:"followers"`
}

type DescribedPlaylist struct {
        Message   string                  `json:"message"`
        Playlists SimplifiedPlaylistChunk `json:"playlists"`
}

type Snapshot struct {
        SnapshotId string `json:"snapshot_id"`
}

func (s *Spotify) GetPlaylist(id string, params ...Param) (*FullPlaylist, error) <span class="cov8" title="1">{
        playlist := &amp;FullPlaylist{}
        err := s.Get(playlist, fmt.Sprintf("/playlists/%s", id), params...)
        return playlist, err
}</span>

func (s *Spotify) ChangePlaylistDetails(
        id, name, description string,
        public, collaborative bool,
) error <span class="cov8" title="1">{
        w := struct {
                Name          string `json:"name"`
                Public        bool   `json:"public"`
                Collaborative bool   `json:"collaborative"`
                Description   string `json:"description"`
        }{
                name,
                public,
                collaborative,
                description,
        }
        body, err := json.Marshal(w)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return s.Put(nil, fmt.Sprintf("/playlist/%s", id), body)</span>
}

func (s *Spotify) GetPlaylistItems(id string, params ...Param) (*PlaylistTrackChunk, error) <span class="cov8" title="1">{
        trackChunck := &amp;PlaylistTrackChunk{}
        err := s.Get(trackChunck, fmt.Sprintf("/playlists/%s/tracks", id), params...)
        return trackChunck, err
}</span>

func (s *Spotify) UpdatePlaylistItems(
        id, snapshotId string,
        rangeStart, insertBefore int,
        URIs []string,
        params ...Param,
) (*Snapshot, error) <span class="cov8" title="1">{
        snapshot := &amp;Snapshot{}
        w := struct {
                URIs         []string `json:"uris"`
                RangeStart   int      `json:"range_start"`
                InsertBefore int      `json:"insert_before"`
                SnapshotId   string   `json:"snapshot_id"`
        }{
                URIs,
                rangeStart,
                insertBefore,
                snapshotId,
        }
        body, err := json.Marshal(w)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = s.Put(snapshot, fmt.Sprintf("/playlists/%s/tracks", id), body, params...)
        return snapshot, err</span>
}

func (s *Spotify) AddItemsToPlaylist(
        id string,
        position int,
        URIs []string,
        params ...Param,
) (*Snapshot, error) <span class="cov8" title="1">{
        snapshot := &amp;Snapshot{}
        w := struct {
                URIs     []string `json:"uris"`
                Position int      `json:"position"`
        }{
                URIs,
                position,
        }
        body, err := json.Marshal(w)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = s.Put(snapshot, fmt.Sprintf("/playlists/%s/tracks", id), body, params...)
        return snapshot, err</span>
}

func (s *Spotify) RemovePlaylistItem(id, snapshotId string, tracks interface{}) (*Snapshot, error) <span class="cov8" title="1">{
        snapshot := &amp;Snapshot{}
        w := struct {
                Tracks     interface{} `json:"tracks"`
                SnapshotId string      `json:"snapshot_id"`
        }{
                tracks,
                snapshotId,
        }
        body, err := json.Marshal(w)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = s.Delete(snapshot, fmt.Sprintf("/playlists/%s/tracks", id), body)
        return snapshot, err</span>
}

func (s *Spotify) GetCurrentUserPlaylists(params ...Param) (*SimplifiedPlaylistChunk, error) <span class="cov8" title="1">{
        playlistChunk := &amp;SimplifiedPlaylistChunk{}
        err := s.Get(playlistChunk, "/me/playlists")
        return playlistChunk, err
}</span>

func (s *Spotify) GetUserPlaylists(
        userId string,
        params ...Param,
) (*SimplifiedPlaylistChunk, error) <span class="cov8" title="1">{
        playlistChunk := &amp;SimplifiedPlaylistChunk{}
        err := s.Get(playlistChunk, fmt.Sprintf("/users/%s/playlists", userId))
        return playlistChunk, err
}</span>

func (s *Spotify) CreatePlaylist(
        userId, name, description string,
        public, collaborative bool,
) error <span class="cov8" title="1">{
        w := struct {
                Name          string `json:"name"`
                Public        bool   `json:"snapshot_id"`
                Collaborative bool   `json:"collaborative"`
                Description   string `json:"description"`
        }{
                name,
                public,
                collaborative,
                description,
        }
        body, err := json.Marshal(w)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return s.Post(nil, fmt.Sprintf("/users/%s/playlists", userId), body)</span>
}

func (s *Spotify) GetFeaturedPlaylists(params ...Param) (*DescribedPlaylist, error) <span class="cov8" title="1">{
        describedPlaylist := &amp;DescribedPlaylist{}
        err := s.Get(describedPlaylist, "/browse/featured-playlists", params...)
        return describedPlaylist, err
}</span>

func (s *Spotify) GetCategoryPlaylists(
        categoryId string,
        params ...Param,
) (*DescribedPlaylist, error) <span class="cov8" title="1">{
        describedPlaylist := &amp;DescribedPlaylist{}
        err := s.Get(
                describedPlaylist,
                fmt.Sprintf("/browse/categories/%s/playlists", categoryId),
                params...)
        return describedPlaylist, err
}</span>

func (s *Spotify) GetPlaylistCoverImage(id string) ([]*Image, error) <span class="cov8" title="1">{
        image := []*Image{}
        err := s.Get(&amp;image, fmt.Sprintf("/playlists/%s/images", id))
        return image, err
}</span>

func (s *Spotify) AddCustomPlaylistCoverImage(id, data string) error <span class="cov8" title="1">{
        return s.PutImage(nil, fmt.Sprintf("/playlists/%s/images", id), data)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package api

import (
        "fmt"
        "strings"
)

type SearchResult struct {
        Tracks     FullTrackChunk           `json:"tracks"`
        Artists    FullArtistChunk          `json:"artists"`
        Albums     SimplifiedAlbumChunk     `json:"albums"`
        Playlists  SimplifiedPlaylistChunk  `json:"playlists"`
        Shows      SimplifiedShowChunk      `json:"shows"`
        Episodes   SimplifiedEpisodeChunk   `json:"episodes"`
        Audiobooks SimplifiedAudiobookChunk `json:"audiobooks"`
}

func (s *Spotify) Search(q string, types []string, params ...Param) (*SearchResult, error) <span class="cov8" title="1">{
        result := &amp;SearchResult{}
        err := s.Get(
                result,
                fmt.Sprintf("/search?q=%s&amp;type=%s", q, strings.Join(types, ",")),
                params...)
        return result, err
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package api

import (
        "fmt"
        "strings"
)

type SimplifiedShow struct {
        AvailableMarkets   []string    `json:"available_markets"`
        Copyrights         []Copyright `json:"copyrights"`
        Description        string      `json:"description"`
        HtmlDescription    string      `json:"html_description"`
        Explicit           bool        `json:"explicit"`
        ExternalURLs       ExternalURL `json:"external_urls"`
        Href               string      `json:"href"`
        Id                 string      `json:"id"`
        Images             []Image     `json:"images"`
        IsExternallyHosted bool        `json:"is_externally_hosted"`
        Languages          []string    `json:"languages"`
        MediaType          string      `json:"media_type"`
        Name               string      `json:"name"`
        Publisher          string      `json:"publisher"`
        Type               string      `json:"type"`
        URI                string      `json:"uri"`
        TotalEpisodes      int         `json:"total_episodes"`
}

type FullShow struct {
        SimplifiedShow
        Episodes SimplifiedEpisodeChunk `json:"episodes"`
}

func (s *Spotify) GetShow(id string, params ...Param) (*FullShow, error) <span class="cov8" title="1">{
        show := &amp;FullShow{}
        err := s.Get(show, fmt.Sprintf("/shows/%s", id), params...)
        return show, err
}</span>

func (s *Spotify) GetShows(ids []string, params ...Param) ([]*FullShow, error) <span class="cov8" title="1">{
        var w struct {
                Shows []*FullShow `json:"shows"`
        }
        err := s.Get(&amp;w, fmt.Sprintf("/shows?ids=%s", strings.Join(ids, ",")), params...)
        return w.Shows, err
}</span>

func (s *Spotify) GetShowEpisodes(id string, params ...Param) (*SimplifiedEpisodeChunk, error) <span class="cov8" title="1">{
        episodeChunk := &amp;SimplifiedEpisodeChunk{}
        err := s.Get(episodeChunk, fmt.Sprintf("/shows/%s/episodes", id), params...)
        return episodeChunk, err
}</span>

func (s *Spotify) GetUserSavedShows(params ...Param) (*SimplifiedShowChunk, error) <span class="cov8" title="1">{
        showChunk := &amp;SimplifiedShowChunk{}
        err := s.Get(showChunk, "/me/shows", params...)
        return showChunk, err
}</span>

func (s *Spotify) SaveShowsForCurrentUser(ids []string) error <span class="cov8" title="1">{
        return s.Put(nil, fmt.Sprintf("/me/shows?ids=%s", strings.Join(ids, ",")), []byte{})
}</span>

func (s *Spotify) RemoveUserSavedShows(ids []string) error <span class="cov8" title="1">{
        return s.Delete(nil, fmt.Sprintf("/me/shows?ids=%s", strings.Join(ids, ",")), []byte{})
}</span>

func (s *Spotify) CheckUserSavedShows(ids []string) ([]bool, error) <span class="cov8" title="1">{
        containmentInfo := []bool{}
        err := s.Get(&amp;containmentInfo, fmt.Sprintf("/me/shows/contains?ids=%s", strings.Join(ids, ",")))
        return containmentInfo, err
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package api

import (
        "fmt"
        "strings"
)

type SimplifiedTrack struct {
        AudioRecording
        Artists          []SimplifiedArtist `json:"artists"`
        AvailableMarkets []string           `json:"available_markets"`
        DiscNumber       int                `json:"disc_number"`
        LinkedFrom       Linked             `json:"linked_from"`
        Popularity       int                `json:"popularity"`
        PreviewURL       string             `json:"preview_url"`
        TrackNumber      int                `json:"track_number"`
        Type             string             `json:"type"`
        URI              string             `json:"uri"`
        IsLocal          bool               `json:"is_local"`
}

type Linked struct {
        ExternalURLs ExternalURL `json:"external_urls"`
        Href         string      `json:"href"`
        Id           string      `json:"id"`
        Type         string      `json:"type"`
        URI          string      `json:"uri"`
}

type FullTrack struct {
        SimplifiedTrack
        Album       SimplifiedAlbum `json:"album"`
        ExternalIds ExternalId      `json:"external_ids"`
}

type SavedTrack struct {
        AddedAt string    `json:"added_at"`
        Track   FullTrack `json:"track"`
}

type RecommendationSeed struct {
        AfterFilteringSize int    `json:"after_filtering_size"`
        AfterRelinkingSize int    `json:"after_relinking_size"`
        Href               string `json:"href"`
        Id                 string `json:"id"`
        InitialPoolSize    int    `json:"initial_pool_size"`
        Type               string `json:"type"`
}

type Recommendation struct {
        Seeds  []RecommendationSeed `json:"seeds"`
        Tracks []FullTrack          `json:"tracks"`
}

type AudioFeature struct {
        Accousticness    float32 `json:"accousticness"`
        AnalysisUrl      string  `json:"analysis_url"`
        Danceability     float32 `json:"danceability"`
        DurationMs       int     `json:"duration_ms"`
        Energy           float32 `json:"energy"`
        Id               string  `json:"id"`
        Instrumentalness float32 `json:"instrumentalness"`
        Key              int     `json:"key"`
        Liveness         float32 `json:"liveness"`
        Loudness         float32 `json:"loudness"`
        Mode             int     `json:"mode"`
        Speechiness      float32 `json:"speechiness"`
        Tempo            float32 `json:"tempo"`
        TimeSignature    int     `json:"time_signature"`
        TrackHref        string  `json:"track_href"`
        Type             string  `json:"type"`
        URI              string  `json:"uri"`
        Valence          float32 `json:"valence"`
}

type Meta struct {
        AnalyzerVersion string  `json:"analyzer_version"`
        Platform        string  `json:"platform"`
        DetailedStatus  string  `json:"detailed_status"`
        StatusCode      int     `json:"status_code"`
        Timestamp       int     `json:"timestamp"`
        AnalysisTime    float32 `json:"analysis_time"`
        InputProcess    string  `json:"input_process"`
}

type BaseAudioAnalysis struct {
        Loudness                float32 `json:"loudness"`
        Tempo                   float32 `json:"tempo"`
        TempoConfidence         float32 `json:"tempo_confidence"`
        Key                     int     `json:"key"`
        KeyConfidence           float32 `json:"key_confidence"`
        Mode                    int     `json:"mode"`
        ModeConfidence          float32 `json:"mode_confidence"`
        TimeSignature           int     `json:"time_signature"`
        TimeSignatureConfidence float32 `json:"time_signature_confidence"`
}

type TrackAnalysis struct {
        BaseAudioAnalysis
        NumSamples         int     `json:"num_samples"`
        Duration           float32 `json:"duration"`
        SampleMd5          string  `json:"sample_md_5"`
        OffsetSeconds      int     `json:"offset_seconds"`
        WindowSeconds      int     `json:"window_seconds"`
        AnalysisSampleRate int     `json:"analysis_sample_rate"`
        AnalysisChannels   int     `json:"analysis_channels"`
        EndOfFadeIn        float32 `json:"end_of_fade_in"`
        StartOfFadeOut     float32 `json:"start_of_fade_out"`
        Codestring         string  `json:"codestring"`
        CodeVersion        float32 `json:"code_version"`
        Echoprintstring    string  `json:"echoprintstring"`
        EchoprintVersion   float32 `json:"echoprint_version"`
        Synchstring        string  `json:"synchstring"`
        SynchVersion       float32 `json:"synch_version"`
        Rhythmstring       string  `json:"rhythmstring"`
        RhythmVersion      float32 `json:"rhythm_version"`
}

type Interval struct {
        Start      float32 `json:"start"`
        Duration   float32 `json:"duration"`
        Confidence float32 `json:"confidence"`
}

type Sections struct {
        Interval
        BaseAudioAnalysis
}

type Segments struct {
        Interval
        LoudnessStart float32   `json:"loudness_start"`
        LoudnessMax   float32   `json:"loudness_max"`
        LoudnessEnd   float32   `json:"loudness_end"`
        Pitches       []float32 `json:"pitches"`
        Timbre        []float32 `json:"timbre"`
}

type AudioAnalysis struct {
        Meta     Meta          `json:"meta"`
        Track    TrackAnalysis `json:"track"`
        Bars     []Interval    `json:"bars"`
        Beats    []Interval    `json:"beats"`
        Sections []Sections    `json:"sections"`
        Segments []Segments    `json:"segments"`
        Tatums   []Interval    `json:"tatums"`
}

func (s *Spotify) GetTrack(id string, params ...Param) (*FullTrack, error) <span class="cov8" title="1">{
        track := &amp;FullTrack{}
        err := s.Get(track, fmt.Sprintf("/tracks/%s", id), params...)
        return track, err
}</span>

func (s *Spotify) GetTracks(ids []string, params ...Param) ([]*FullTrack, error) <span class="cov8" title="1">{
        var w struct {
                Tracks []*FullTrack `json:"tracks"`
        }
        err := s.Get(&amp;w, fmt.Sprintf("/tracks?ids=%s", strings.Join(ids, ",")), params...)
        return w.Tracks, err
}</span>

func (s *Spotify) GetUserSavedTracks(params ...Param) (*SavedTrackChunk, error) <span class="cov8" title="1">{
        trackChunk := &amp;SavedTrackChunk{}
        err := s.Get(trackChunk, "/me/tracks", params...)
        return trackChunk, err
}</span>

func (s *Spotify) SaveTracksForCurrentUser(ids []string) error <span class="cov8" title="1">{
        return s.Put(nil, fmt.Sprintf("/me/tracks?ids=%s", strings.Join(ids, ",")), []byte{})
}</span>

func (s *Spotify) RemoveUserSavedTracks(ids []string) error <span class="cov8" title="1">{
        return s.Delete(nil, fmt.Sprintf("/me/tracks?ids=%s", strings.Join(ids, ",")), []byte{})
}</span>

func (s *Spotify) CheckUserSavedTracks(ids []string) ([]bool, error) <span class="cov8" title="1">{
        containmentInfo := []bool{}
        err := s.Get(
                &amp;containmentInfo,
                fmt.Sprintf("/me/tracks/contains?ids=%s", strings.Join(ids, ",")),
        )
        return containmentInfo, err
}</span>

func (s *Spotify) GetTracksAudioFeatures(ids []string) ([]*AudioFeature, error) <span class="cov8" title="1">{
        var w struct {
                AudioFeatures []*AudioFeature `json:"audio_features"`
        }
        err := s.Get(&amp;w, fmt.Sprintf("/audio-features?ids=%s", strings.Join(ids, ",")))
        return w.AudioFeatures, err
}</span>

func (s *Spotify) GetTrackAudioFeatures(id string) (*AudioFeature, error) <span class="cov8" title="1">{
        audioFeature := &amp;AudioFeature{}
        err := s.Get(audioFeature, fmt.Sprintf("/audio-features/%s", id))
        return audioFeature, err
}</span>

func (s *Spotify) GetTrackAudioAnalysis(id string) (*AudioAnalysis, error) <span class="cov8" title="1">{
        audioAnalysis := &amp;AudioAnalysis{}
        err := s.Get(audioAnalysis, fmt.Sprintf("/audio-analysis/%s", id))
        return audioAnalysis, err
}</span>

func (s *Spotify) GetRecommendations(params ...Param) (*Recommendation, error) <span class="cov8" title="1">{
        recommendation := &amp;Recommendation{}
        err := s.Get(recommendation, "/recommendations", params...)
        return recommendation, err
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package api

import (
        "encoding/json"
        "fmt"
        "strings"
)

type ExplicitContent struct {
        FilterEnabled bool `json:"filter_enabled"`
        FilterLocked  bool `json:"filter_locked"`
}

type User struct {
        Country         string          `json:"country"`
        DisplayName     string          `json:"display_name"`
        Email           string          `json:"email"`
        ExplicitContent ExplicitContent `json:"explicit_content"`
        ExternalURLs    ExternalURL     `json:"external_ur_ls"`
        Followers       Follower        `json:"followers"`
        Href            string          `json:"href"`
        Id              string          `json:"id"`
        Images          []Image         `json:"images"`
        Product         string          `json:"product"`
        Type            string          `json:"type"`
        URI             string          `json:"uri"`
}

func (s *Spotify) GetCurrentUserProfile() (*User, error) <span class="cov8" title="1">{
        user := &amp;User{}
        err := s.Get(user, "/me")
        return user, err
}</span>

func (s *Spotify) GetUserTopItems(itemsType string, params ...Param) (*UserItemChunk, error) <span class="cov8" title="1">{
        userItemChunk := &amp;UserItemChunk{}
        err := s.Get(userItemChunk, fmt.Sprintf("/me/top/%s", itemsType), params...)
        return userItemChunk, err
}</span>

func (s *Spotify) GetUserProfile(id string) (*User, error) <span class="cov8" title="1">{
        user := &amp;User{}
        err := s.Get(user, fmt.Sprintf("/me/%s", id))
        return user, err
}</span>

func (s *Spotify) FollowPlaylist(playlistId string, public bool) error <span class="cov8" title="1">{
        w := struct {
                Public bool `json:"public"`
        }{
                public,
        }
        body, err := json.Marshal(w)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return s.Put(nil, fmt.Sprintf("/playlist/%s/followers", playlistId), body)</span>
}

func (s *Spotify) UnfollowPlaylist(playlistId string) error <span class="cov8" title="1">{
        return s.Delete(nil, fmt.Sprintf("/playlist/%s/followers", playlistId), []byte{})
}</span>

func (s *Spotify) GetFollowedArtists(idType string, params ...Param) (*FullArtistChunk, error) <span class="cov8" title="1">{
        artist := &amp;FullArtistChunk{}
        err := s.Get(artist, fmt.Sprintf("/me/following?type=%s", idType), params...)
        return artist, err
}</span>

func (s *Spotify) FollowArtistsOrUsers(idType string, ids []string) error <span class="cov8" title="1">{
        return s.Put(
                nil,
                fmt.Sprintf("/me/following?type=%s&amp;ids=%s", idType, strings.Join(ids, ",")),
                []byte{},
        )
}</span>

func (s *Spotify) UnfollowArtistsOrUsers(idType string, ids []string) error <span class="cov8" title="1">{
        return s.Delete(
                nil,
                fmt.Sprintf("/me/following?type=%s&amp;ids=%s", idType, strings.Join(ids, ",")),
                []byte{},
        )
}</span>

func (s *Spotify) CheckIfUserFollowsArtistsOrUsers(idType string, ids []string) ([]bool, error) <span class="cov8" title="1">{
        followInfo := []bool{}
        err := s.Get(
                &amp;followInfo,
                fmt.Sprintf("/me/following/contains?type=%s&amp;ids=%s", idType, strings.Join(ids, ",")),
        )
        return followInfo, err
}</span>

func (s *Spotify) CheckIfUsersFollowPlaylist(playlistId string, ids []string) ([]bool, error) <span class="cov8" title="1">{
        followInfo := []bool{}
        err := s.Get(
                &amp;followInfo,
                fmt.Sprintf("/playlists/%s/followers/contains?ids=%s", playlistId, strings.Join(ids, ",")),
        )
        return followInfo, err
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package api

import (
        "encoding/json"
        "fmt"
        "reflect"
)

type ExternalURL struct {
        Spotify string `json:"spotify"`
}

type ExternalId struct {
        Isrc string `json:"isrc"`
        Ean  string `json:"ean"`
        Upc  string `json:"upc"`
}

type Follower struct {
        Href  string  `json:"href"`
        Total float64 `json:"total"`
}

type Image struct {
        URL    string  `json:"url"`
        Height float64 `json:"height"`
        Width  float64 `json:"width"`
}

type Restriction struct {
        Reason string `json:"reason"`
}

type AudioResumePoint struct {
        FullyPlayed      bool `json:"fully_played"`
        ResumePositionMs int  `json:"resume_position_ms"`
}

type AudioRecording struct {
        DurationMs   int         `json:"duration_ms"`
        Explicit     bool        `json:"explicit"`
        ExternalURLs ExternalURL `json:"external_urls"`
        Href         string      `json:"href"`
        Id           string      `json:"id"`
        IsPlayable   bool        `json:"is_playable"`
        Name         string      `json:"name"`
        Restrictions Restriction `json:"restrictions"`
}

type Item struct {
        Artist  FullArtist
        Track   FullTrack
        Episode FullEpisode
        Type    string
}

type ItemType int

const itemTypeField = "Type"
const (
        Artist ItemType = iota
        Track
        Episode
)

func (it ItemType) String() string <span class="cov8" title="1">{
        switch it </span>{
        case Artist:<span class="cov8" title="1">
                return "artist"</span>
        case Track:<span class="cov8" title="1">
                return "track"</span>
        case Episode:<span class="cov0" title="0">
                return "episode"</span>
        }

        <span class="cov0" title="0">return "missing type"</span>
}

func (i *Item) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        if len(data) == 0 || string(data) == "null" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">pairs := make(map[string]interface{})
        err := json.Unmarshal(data, &amp;pairs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">itemType, ok := pairs["type"]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("item type missing")
        }</span>

        <span class="cov8" title="1">switch itemType </span>{
        case Artist.String():<span class="cov8" title="1">
                a := FullArtist{}
                if err := i.parse(data, a, Artist.String(), "Artist"); err == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
        case Track.String():<span class="cov8" title="1">
                t := FullTrack{}
                if err := i.parse(data, t, Track.String(), "Track"); err == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
        case Episode.String():<span class="cov0" title="0">
                e := FullEpisode{}
                if err := i.parse(data, e, Episode.String(), "Episode"); err == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("unsupported item type")</span>
}

func (i *Item) parse(data []byte, itemStruct interface{}, itemType, itemField string) error <span class="cov8" title="1">{
        structValue := reflect.New(reflect.TypeOf(itemStruct)).Elem()
        if err := json.Unmarshal(data, structValue.Addr().Interface()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">itemValue := reflect.ValueOf(i).Elem()
        itemValue.FieldByName(itemTypeField).SetString(itemType)
        itemValue.FieldByName(itemField).Set(structValue)
        return nil</span>
}

func (s *Spotify) GetAvailableGenreSeeds() (*[]string, error) <span class="cov8" title="1">{
        var w struct {
                Genres *[]string `json:"genres"`
        }
        err := s.Get(&amp;w, "/recommendations/available-genre-seeds")
        return w.Genres, err
}</span>

func (s *Spotify) GetAvailableMarkets() (*[]string, error) <span class="cov8" title="1">{
        var w struct {
                Markets *[]string `json:"markets"`
        }
        err := s.Get(&amp;w, "/markets")
        return w.Markets, err
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package auth

import (
        "context"
        "os"

        "golang.org/x/oauth2"
)

type Service struct {
        conf *oauth2.Config
}

func (s *Service) addOption(op option) <span class="cov0" title="0">{
        op(s)
}</span>

func (s *Service) addOptions(ops []option) <span class="cov0" title="0">{
        for _, op := range ops </span><span class="cov0" title="0">{
                op(s)
        }</span>
}

func (s *Service) AuthURL(state string, opts ...oauth2.AuthCodeOption) string <span class="cov0" title="0">{
        return s.conf.AuthCodeURL(state, opts...)
}</span>

func (s *Service) Exchange(
        ctx context.Context,
        code string,
        opts ...oauth2.AuthCodeOption,
) (*oauth2.Token, error) <span class="cov0" title="0">{
        return s.conf.Exchange(ctx, code, opts...)
}</span>

func NewService(ops ...option) Service <span class="cov0" title="0">{
        s := Service{
                conf: &amp;oauth2.Config{
                        ClientID:     os.Getenv("SPOTIFY_CLIENT_ID"),
                        ClientSecret: os.Getenv("SPOTIFY_CLIENT_SECRET"),
                        Endpoint: oauth2.Endpoint{
                                AuthURL:  "https://accounts.spotify.com/authorize",
                                TokenURL: "https://accounts.spotify.com/api/token",
                        },
                },
        }
        s.addOptions(ops)

        return s
}</span>

type option func(s *Service)

func RedirectURL(url string) option <span class="cov0" title="0">{
        return func(s *Service) </span><span class="cov0" title="0">{
                s.conf.RedirectURL = url
        }</span>
}

// Add scopes by using conf.Scopes
</pre>
		
		<pre class="file" id="file17" style="display: none">package services

import (
        "context"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
)

func runCallbackServer(code *string) <span class="cov0" title="0">{
        http.HandleFunc("/callback", handleCallback(code))
        s := &amp;http.Server{Addr: "localhost:8888"}

        go func() </span><span class="cov0" title="0">{
                sigint := make(chan os.Signal, 1)
                signal.Notify(sigint, os.Interrupt)
                &lt;-sigint

                if err := s.Shutdown(context.Background()); err != nil </span><span class="cov0" title="0">{
                        log.Fatal("HTTP server shutdown error: ", err)
                }</span>
        }()

        <span class="cov0" title="0">if err := s.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                fmt.Println("Callback Server Closed")
        }</span>
}

func handleCallback(code *string) http.HandlerFunc <span class="cov0" title="0">{
        return func(_ http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                q := r.URL.Query()
                if !q.Has("code") </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">*code = q.Get("code")
                syscall.Kill(syscall.Getpid(), syscall.SIGINT)</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package services

import (
        "context"
        "log"
        "os/exec"

        "github.com/Alieksieiev0/sgotify/pkg/auth"
        "golang.org/x/oauth2"
)

type Terminal struct {
        service auth.Service
}

func (t Terminal) Authorize(ctx context.Context) (*oauth2.Token, error) <span class="cov0" title="0">{
        cmd := exec.Command("xdg-open", t.service.AuthURL("state"))
        err := cmd.Start()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("failure starting open command: ", err)
        }</span>

        <span class="cov0" title="0">var code string
        runCallbackServer(&amp;code)
        token, err := t.service.Exchange(ctx, code)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return token, nil</span>
}

func NewTerminal(redirectURL string) Terminal <span class="cov0" title="0">{
        return Terminal{
                service: auth.NewService(auth.RedirectURL(redirectURL)),
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
